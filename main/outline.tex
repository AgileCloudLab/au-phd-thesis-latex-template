% !TEX root = /home/xiaobo/Dropbox/Dissertation/main.tex

\chapter{\label{chp:outline}Thesis Outline}
\vspace{-2 cm}
\epigraph{A journey of a thousand miles begins with a single step.}{\textit{Lao Tzu}}


% 	\noindent This thesis studies the reliable storage in \gls{IoT} scenarios, following the roadmap shown in Fig.~\ref{fig.introduction.roadmap} to address the questions and objectives outlines in Chapter~\ref{ch.objectives}.
% 	As mentioned in Chapter~\ref{ch.objectives}, the redundancy injected in the preparation stage affects the bandwidth in the subsequent repair stages.
% 	As will be seen in Section~\ref{sec.trade-off}, we reveal that there is a trade-off between early redundancy injection costs and repair costs, and a judicious choice between the preparation and repair costs can result in a considerable reduction of network cost with respect to a naive selection.

% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[!ht]
% 		\centering
% 		\includegraphics[width=1.0\textwidth, height=12.5cm]{figures/introduction/Research roadmap.pdf}
% 		\caption{The research roadmap of this thesis.}
% 		\label{fig.introduction.roadmap}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 	Then, one might ask how much the maximum reduction could be.
% 	In other words, what is the lower bound of the total cost from preparation to repair stages?
% 	The entire process is defined as the \emph{protection problem}, where the generated data is protected from permanent loss caused by device failures.
% 	This total cost is called the \emph{protection bandwidth}.
% 	The optimal solution that minimizes the protection bandwidth as well as the storage requirement will be given in Section~\ref{sec.minimum_bandwidth}, and more details in~\ref{paper.cl2018}.

% 	In spite of the optimality of the solution, the complexity of driving the optimal solution is high, which might hinder its use when network sizes are large.
% 	In order to reduce the complexity, we propose a low complexity relaxation of the optimal solution, which will be seen in Section~\ref{sec.low_complexity}.
% 	With two \gls{RLNC}-based solutions for the data protection problem, we proceed to study the impact of \gls{RLNC} parameters on their performance.
% 	In Section~\ref{sec.optimal_g}, we focus on the effect of the generation size, and provide the optimal generation size.
% 	Next, an implementation of the low complexity of the protection problem is presented in Section~\ref{sec.implementation}, which validates our theoretical results in practice.
% 	Comprehensive descriptions of the content in Sections~\ref{sec.low_complexity}, \ref{sec.optimal_g} and \ref{sec.implementation} can be found in~\ref{paper.iot2019}.

% 	The fact that both aforementioned solutions require remaining nodes to communicate with each other in every single stage leads to numerous connections.
% 	To address this issue, one of remaining nodes is utilized as a leader to coordinate the protection process.
% 	The details are given in Section~\ref{sec.leader} (\ref{paper.cl2019}).
% 	As a generalization of the work in Section~\ref{sec.leader}, the protection problem with random device failures is considered in Section~\ref{sec.random_failures} (\ref{paper.ew2019}).

% 	\section{Trade-off between Early Redundancy Injection Costs and Repair Costs}
% 	\label{sec.trade-off}

% 	In \gls{IoT} scenarios, not only repairing failures but also introducing initial redundancy consumes system resources, therefore we consider the overall protection bandwidth rather than only the repair bandwidth.
% 	The preparation stage has an effect on subsequent repair stage(s).
% 	For example, the bandwidth of one or more repair stages can become zero if in the preparation stage sufficient redundancy has been injected into the system.
% 	An extreme and wasteful case occurs when the preparation stage generates full copies of the data in all nodes, thus making any data exchange after losses unnecessary.
% 	Therefore, we first study how the preparation cost affects the repair cost.

% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[H]
% 		\centering
% 		\subfloat[Preparation cost]{\includegraphics[width=0.33\textwidth]{figures/introduction/MSR1.eps}}
% 		% \hspace{1cm}
% 		\subfloat[Repair cost]{\includegraphics[width=0.33\textwidth,trim={0 0cm 0 0}]{figures/introduction/MSR2.eps}}
% 		\subfloat[Protection cost]{\includegraphics[width=0.33\textwidth,trim={0 0cm 0 0}]{figures/introduction/MSR3.eps}}
% 		\caption{Costs in preparation phase and repair phase for different policies with \gls{MSR} codes (figure from~\cite{zhao2017reliable}).}
% 		\label{fig.introduction.msr}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[H]
% 		\centering
% 		\subfloat[Preparation cost]{\includegraphics[width=0.33\textwidth]{figures/introduction/MBR1.eps}}
% 		% \hspace{1cm}
% 		\subfloat[Repair cost]{\includegraphics[width=0.33\textwidth,trim={0 0cm 0 0}]{figures/introduction/MBR2.eps}}
% 		\subfloat[Protection cost]{\includegraphics[width=0.33\textwidth,trim={0 0cm 0 0}]{figures/introduction/MBR3.eps}}
% 		\caption{Costs in preparation phase and repair phase for different policies with \gls{MBR} codes (figure from~\cite{zhao2017reliable}).}
% 		\label{fig.introduction.mbr}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 	Fig.~\ref{fig.introduction.msr} and Fig.~\ref{fig.introduction.mbr} show the costs of different policies when using \gls{MSR} and \gls{MBR} points, respectively.
% 	Regarding the policies, they are in the form of $(p, r, w)$, which  represents a protection policy that prepares for $p$ node losses, then repairs $p$ node losses and guards against another $r$ node losses for $w$ times.
% 	From a redundancy perspective, a policy denotes the amount of redundancy generated in different stages.
% 	Take Fig.~\ref{fig.introduction.msr} as an example.
% 	When the policies transition between \gls{MSR} points, the policy that has the smallest protection cost is neither the one achieving least preparation cost nor the one achieving least repair cost, but the one well trades off the two costs.
% 	A similar result for \gls{MBR} codes can be found in Fig.~\ref{fig.introduction.mbr}.
% 	These results reveal that the cost of introducing redundancy at the beginning of the storage process has a critical role in the overall cost to the system.
% 	Additionally, the timing and quantity of redundancy introduced as multiple nodes suffer failures has an effect on reducing the repair cost of failures.
% 	These results allowed us to accomplish \ref{itm:obj1} of Chapter~\ref{ch.objectives}.
% 	Next, we are interested in seeking the policy with minimum bandwidth for a protection problem.

% 	\section{Minimum Bandwidth Use in IoT Storage Without Newcomer Nodes}
% 	\label{sec.minimum_bandwidth}

% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[!ht]
% 		\centering
% 		\includegraphics[width=0.90\textwidth]{figures/introduction/Protection problem.pdf}
% 		\caption{The considered data protection problem (figure from~\ref{paper.iot2019}).}
% 		\label{fig.introduction.protectionproblem}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 	We proceed to study the protection problem from a more general perspective, i.e., capturing the overall process of data transmission between IoT devices from the initial preparation stage to the different repair stages with fewer and fewer devices.
% 	As depicted in Fig.~\ref{fig.introduction.protectionproblem}, we consider an $n$-node network has $M$ bytes of initial data, where each node has generated $M / n$ bytes.
% 	Nodes can fail one at a time, and the data in the failed node will be lost.
% 	For simplicity, we assume that the network is fully connected, i.e., there is direct communication between each device, and that each node has the same probability of failure.
% 	To protect data from failures, redundancy is injected into the system, and the data will be recovered by a data collector at the end of the process, even if only $k$ $(1 \leq k < n)$ nodes survive.
% 	Any $k$ nodes are sufficient to retrieve the original data.
% 	We refer to a data protection problem with no newcomers of $n$ original and $k$ surviving nodes as $\mathbb{P}(n, k)$.

% 	In the preparation stage, as shown in Fig.~\ref{fig.introduction.protectionproblem}a, the system encodes the data with network coding and distributes coded data from each device to the others to achieve a certain redundancy across the $n$ nodes.
% 	This stage is not typically considered in previous literature due to the fact that with sufficient repairs, its effect vanishes.
% 	But this is not the case for our work.
% 	When a node fails, a repair stage is carried out, in which any two nodes communicate with each other to recover the lost redundancy and guarantee that subsequent node failures will not cause permanent loss of data, as shown in Fig.~\ref{fig.introduction.protectionproblem}b.
% 	It is assumed that no new failure occurs before the repair of the previous node failure is accomplished.
% 	Since the preparation stage can be regarded as a special repair stage\footnote{If we consider that there is a loss of a virtual node and $n$ nodes remain after that loss, the preparation stage is a special repair stage.}, we will not distinguish between preparation bandwidth and repair bandwidth in our analysis.
% 	All transmissions during the protection process are assumed to be error-free.
% 	The costs of network management are negligible compared to those incurred for carrying out the repairs.

% 	% Network coding is introduced as an efficient technique for distributed storage systems in~\cite{dimakis2010network}, where the repair problem is mapped to a multicast problem based on an information flow graph.
% 	% It has been shown that a multicast problem is solvable if and only if the max-flow min-cut bound is satisfied by linear network coding~\cite{koetter2003algebraic}, and by \gls{RLNC} with probability exponentially approaching 1 with the finite field size~\cite{ho2006random}.
% 	% Referring back to the repair problem, the original data can be reconstructed provided that the minimum capacity of the cuts separating source and data collector is equal or greater than its size.
% 	% Although the formulation is not suitable for the protection problem in \gls{IoT} scenarios, the insight of mapping the repair problem to a multicast problem on an information flow graph is still useful.
% 	% However, it requires a non-trivial adaptation to incorporate the various repair stages and a more complex set of min-cut constraints.

% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[!ht]
% 		\centering
% 		\includegraphics[width=0.80\textwidth]{figures/introduction/Flow_graph.eps}
% 		\caption{An illustration of the protection problem corresponding to $\mathbb{P}(6, 4)$ based on an information flow graph ((figure from~\cite{zhao2018reliable})).}
% 		\label{fig.introduction.flowgraph}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 	We utilize an information flow graph to map the protection problem to a multicast problem.
% 	An example corresponding to $\mathbb{P}(6, 4)$ is given in Fig.~\ref{fig.introduction.flowgraph}.
% 	The information flow graph is a directed acyclic graph, which is composed of three categories of nodes: a source $\mathrm{S}$, ordinary nodes $\mathrm{N}$'s, and a data collector $\mathrm{DC}$.
% 	Note that $\mathrm{S}$ is either a real source or a virtual one.
% 	The latter is used when each node generates its own data.
% 	In terms of the capacity of edges, $\mathrm{S}$ communicates original information to each ordinary node with a directed edge of infinite capacity, and $\mathrm{DC}$ is linked to every remaining node by a directed edge with infinite capacity.
% 	For the edges in repair stages, the capacity of directed edges between the same node $(\mathrm{N_u} \rightarrow \mathrm{N_u})$ is the storage $\alpha_i$, and that between different nodes $(\mathrm{N_u} \rightarrow \mathrm{N_w})$ is the transmission size $\beta_s$.
% 	$\alpha_i$ denotes the storage in each of the $i$ $(k \leq i \leq n)$ existing nodes, and $\beta_s$ denotes  the amount of data sent from each node in a repair stage involving $s$ $(k + 1 \leq s \leq n)$ nodes.
% 	The protection bandwidth $\delta(n, k)$ is the summation of all $\beta$'s, i.e., $\delta(n, k) = \sum_{s = k + 1}^{n} s(s - 1) \beta_s$.
% 	Note that the notations $\mathrm{N_u}$ and $\mathrm{N_w}$ are employed to distinguish the two edge patterns, and they do not refer to specific nodes.

% 	For a protection problem, it is solvable if and only if the min-cut of $\mathrm{S}$-$\mathrm{DC}$ cuts in each repair stage is greater than or equal to the original data size $M$.
% 	Nevertheless, only the size of data originally stored in each node $\alpha_n$ is known, and the values of $\alpha_k, \ldots, \alpha_{n - 1}, \beta_{k + 1}, \ldots, \beta_n$ will vary with different strategies being employed.
% 	Without the capacity of edges, the capacity of a cut cannot be obtained, and then the min-cut cannot be determined.
% 	Given this, we consider to let all $\mathrm{S}$-$\mathrm{DC}$ cuts (with finite capacity) in each stage satisfy the data reconstruction condition, then every min-cut must satisfy the condition.
% 	In the protection problem, if there is more than one failure and the min-cut in a certain repair is smaller than $M$, the original data cannot be retrieved regardless of how much redundancy injected into the system in following repair(s).
% 	Unlike the more general protection problem considering all losses at once, we choose a sequence of events for them, which provides a better comprehension of the metric relationship for two successive repair stages.
% 	Moreover, due to the problem's symmetry, we can focus on one path, i.e., one set of remaining nodes, with the understanding that each of the other paths will contribute to the traffic $\beta$.
% 	As the example in Fig~\ref{fig.introduction.flowgraph}, we focus only on the beneficial transmissions, which carry information that would be lost otherwise when losing nodes $\mathrm{N_6}$ and $\mathrm{N_5}$.
% 	The transmissions sent from other nodes will be counted in while calculating the protection bandwidth $\delta$.

% 	Fig.~\ref{fig.introduction.flowgraph} shows two repair phases for a six-node system, where $\mathrm{DC}$ can reconstruct the original data after two nodes fail.
% 	We denote the set of all $\mathrm{S}$-$\mathrm{DC}$ cuts with five nodes remaining as $\mathrm{(S,DC)}_{(6, 5)}$, and that with four nodes remaining as $\mathrm{(S,DC)}_{(6, 4)}$.
% 	Since we focus only on $\mathrm{S}$-$\mathrm{DC}$ cuts, we rewrite $\mathrm{(S,DC)}_{(6, 5)}$ and $\mathrm{(S,DC)}_{(6, 4)}$ as $(6, 5)$ and $(6, 4)$ without ambiguity.
% 	To prevent visual clutter, only three typical cuts of $(6, 4)$ are shown in Fig.~\ref{fig.introduction.flowgraph}, but all additional cuts are accounted for in the analysis.
% 	The sets of capacity of all cuts in $(6, 5)$ and $(6, 4)$ are referred to as capacity sets $\boldsymbol{c}(6, 5)$ and $\boldsymbol{c}(6, 4)$, respectively.
% 	It is not difficult to calculate $\boldsymbol{c}(6, 5)$ and $\boldsymbol{c}(6, 4)$.
% 	Based on the analysis before, $\boldsymbol{c}(6, 5) \geq M$ and $\boldsymbol{c}(6, 4) \geq M$ are necessary to reconstruct the original data, i.e., they are the constraints of cut capacity of a problem $\mathbb{P}(6, 4)$.
% 	Combining with the constraints of $\alpha$'s and $\beta$'s, we establish an optimization problem to minimize the protection bandwidth $\delta(6, 4)$ as
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\begin{aligned}
% 	\textbf{(P1)} \quad \text{min} \quad & \delta(6, 4) = 6(6 - 1) \beta_6 + (5 - 1) \beta_5 \\
% 	\text{s.t.} \quad & \boldsymbol{c}(6, 5) \geq M
% 	&& \hspace*{-2cm} \boldsymbol{c}(6, 4) \geq M \\
% 	& \alpha_{6} + 5 \beta_{6} \geq \alpha_5
% 	&& \hspace*{-2cm} \alpha_{5} + 4 \beta_{5} \geq \alpha_4 \\
% 	& 0 \leq \beta_{6} \leq \alpha_{6}
% 	&& \hspace*{-2cm} 0 \leq \beta_{5} \leq \alpha_{5} \\
% 	&\alpha_6 = M / 6 ~,
% 	\end{aligned}
% 	\label{eq.introduction.op_64}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	where the constraints apart from cut capacity are related to storage and repair bandwidth.
% 	Both of the objective function and constraints in Eq.~\eqref{eq.introduction.op_64} are linear, thus, by solving this \gls{LP} problem, we can determine the minimum protection bandwidth $\delta(6, 4)_{min}$, and the optimal protection strategy $(\beta_5, \beta_6)$ that achieves it.
% 	A general formulation for $\mathbb{P}(n, k)$, the minimum protection bandwidth $\delta(n, k)_{min}$ and the optimal strategy $(\beta_{k+1}, \ldots, \beta_n)$ can be found in~\ref{paper.cl2018}.
% 	These results allowed us to accomplish \ref{itm:obj2} and \ref{itm:obj3} of Chapter~\ref{ch.objectives}.

% 	The fact that we consider all $\mathrm{S}$-$\mathrm{DC}$ cuts leads to a large number of min-cut constraints in \gls{LP}, which might hinder the optimal solution's use when the network size is large.
% 	Although in practice this can be handled by establishing clusters of nodes of reasonable size, we are interested in studying relaxations to the min-cut constraints for large $n$.

% 	\section{A Low Complexity Relaxation for Minimizing Bandwidth Use}
% 	\label{sec.low_complexity}

% 	In Section~\ref{sec.minimum_bandwidth}, the reason to consider all $\mathrm{S}$-$\mathrm{DC}$ cuts is that the min-cut in each stage cannot be determined as the $\alpha$'s and $\beta$'s are variables.
% 	To introduce the relaxation, we briefly describe the formulation of all cut constraints.
% 	See \ref{paper.cl2018} for more details.

% 	The set of all $\mathrm{S}$-$\mathrm{DC}$ cuts when $m$ nodes remain is denoted as $(n, m)$, and the capacity set of that is denoted as $\boldsymbol{c}(n, m)$, $k \leq m \leq n - 1$.
% 	Specifically, $\boldsymbol{c}(n, m)$ is formulated as
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\begin{aligned}
%   	 \boldsymbol{c} \left(n, m \right)
%   	  = & \{j_n \alpha_n + j_{n - 1}\alpha_{n - 1} + \cdots + j_m \alpha_m + l_n\beta_n + l_{n - 1}\beta_{n - 1} + \cdots + l_{m + 1} \beta_{m + 1} \vert \\
%   	  & j_{n}, \ldots, j_m \in \mathbb{N} \wedge j_{n}, \ldots, j_m \leq m, l_n, \ldots, l_{m + 1} \in \mathbb{N} \} ~,
% 	\label{eq.introduction.nm}
% 	\end{aligned}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	where $\mathbb{N}$ is the set of all natural numbers,
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\sum_{p = m}^n j_p = m ~,
% 	\label{eq.introduction.jp}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	and
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	l_q = (q - m)\sum_{p = q}^n j_p ~.
% 	\label{eq.introduction.lq}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	Since the cardinality of $\boldsymbol{c} \left(n, m \right)$ is the number of non-negative integer solutions $(j_m, \ldots, j_n)$ in Eq.~\eqref{eq.introduction.jp}, we have $\left| \boldsymbol{c}(n, m) \right| = \binom{n}{m}$.
% 	Clearly, for $\boldsymbol{c}(n, m)$, any two sets with different parameters of $m$ are disjoint, then
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\left| \bigcup\limits_{m = k}^{n - 1} \boldsymbol{c}(n, m) \right| = \sum_{m = k}^{n - 1} \left| \boldsymbol{c}(n, m) \right| = \sum_{m = k}^{n - 1} \binom{n}{m} ~.
% 	% \label{}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	Therefore, in an \gls{LP} for solving $\mathbb{P}(n, k)$, the number of constraints regarding cut capacity is $\sum_{m = k}^{n - 1} \binom{n}{m}$.

% 	With a simple yet effective relaxation, we can reduce the number of cut capacity constraints considerably.
% 	If we let nodes store all data received from each repair stage, i.e., $\alpha_m = \alpha_{m + 1} + m \beta_{m + 1}$, then
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\begin{aligned}
% 	% \begin{cases}
% 	& \alpha_{n - 1} = \alpha_n + (n - 1)\beta_n \\
% 	& \alpha_{n - 2} = \alpha_n + (n - 1)\beta_n + (n - 2)\beta_{n - 1} \\
% 	& \quad \quad \quad \vdots \\
% 	& \alpha_m = \alpha_n + (n - 1)\beta_n + \cdots + m \beta_{m + 1} ~.
% 	% \end{cases}
% 	\end{aligned}
% 	\label{eq.introduction.all_alpha}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	Substituting Eq.~\eqref{eq.introduction.jp}, Eq.~\eqref{eq.introduction.lq} and Eq.~\eqref{eq.introduction.all_alpha} in Eq.~\eqref{eq.introduction.nm}, then the new capacity set $\boldsymbol{c}'(n, m)$ is
% 	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	% \makeatletter
% 	%     \def\tagform@#1{\maketag@@@{\normalsize(#1)\@@italiccorr}}
% 	%     \makeatother
% 	%     \begin{equation}
% 	%     \begin{aligned}
% 	%        \boldsymbol{c}'(n, m)
% 	%            & = \Bigg\{m \alpha_n + \left[(n - m) j_n + (n - 1) \sum_{p = m}^{n - 1} j_p \right] \beta_n + \left[(n - m - 1) (j_n + j_{n - 1}) + (n - 2) \sum_{p = m}^{n - 2} j_p \right] \beta_{n - 1} \\
% 	%            & + \cdots + \left(\sum_{p = m + 1}^n j_p + m j_m \right) \beta_{m + 1} \Big| j_m, \ldots, j_n \in \mathbb{N} \wedge j_m, \ldots, j_n \leq m \Bigg\} ~.
% 	%            \label{eq.introduction.nk_cuts2}
% 	%     \end{aligned}
% 	%     \end{equation}
% 	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \makeatletter
%     \def\tagform@#1{\maketag@@@{\normalsize(#1)\@@italiccorr}}
% \makeatother
% % \footnotesize
% \begin{equation}
% \begin{aligned}
%    \boldsymbol{c}'(n, m)
%     & = \Bigg\{m \alpha_n + \left[(n - m) j_n + (n - 1) \sum_{p = m}^{n - 1} j_p \right] \beta_n + \\
%     & \left[(n - m - 1) (j_n + j_{n - 1}) + (n - 2) \sum_{p = m}^{n - 2} j_p \right] \beta_{n - 1} \\
%     & + \cdots + \left(\sum_{p = m + 1}^n j_p + m j_m \right) \beta_{m + 1} \Big| \\
%     & j_m, \ldots, j_n \in \mathbb{N} \wedge j_m, \ldots, j_n \leq m \Bigg\} ~.
% 	\label{eq.introduction.nk_cuts2}
% \end{aligned}
% \end{equation}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	In $\boldsymbol{c}'(n, m)$, each cut capacity can be denoted as the summation of $m \alpha_n$ and several $\beta$'s.
% 	Examining coefficients of $\beta$'s, we have %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\makeatletter
% 	    \def\tagform@#1{\maketag@@@{\normalsize(#1)\@@italiccorr}}
% 	\makeatother
% 	\begin{equation}
% 	\begin{aligned}
% 	& (n - m) j_n + (n - 1) \sum_{p = m}^{n - 1} j_p \geq (n - m) m \\
% 	& (n - m - 1) (j_n + j_{n - 1}) + (n - 2) \sum_{p = m}^{n - 2} j_p \geq (n - m - 1) m \\
% 	& \quad \quad \quad \vdots \\
% 	& \sum_{p = m + 1}^n j_p + m j_m \geq m ~,
% 	\end{aligned}
% 	\label{eq.introduction.inequ}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	where the inequalities derive from $m \geq 1$ and $\sum_{p = m}^{n} j_p = m$, and the equalities hold when $m = 1$ or $j_n = m$ $\wedge$ $j_m = j_{m + 1} = \cdots = j_{n - 1} = 0$.
% 	In Eq.~\eqref{eq.introduction.nk_cuts2}, $m \alpha_n$ is identical for each capacity and $\beta_{m + 1}, \ldots, \beta_n \geq 0$, so the capacity with the minimum number of coefficients of every $\beta$ is the minimum one of $\boldsymbol{c}'(n, m)$.
% 	Thus, by setting $j_n = m$ $\wedge$ $j_m = j_{m + 1} = \cdots = j_{n - 1} = 0$,
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\begin{aligned}
%    		\text{min}[\boldsymbol{c}'(n, m)]
%    		 & = m \alpha_n + (n - m) m \beta_n + (n - m - 1) m \beta_{n - 1} + \cdots + 1 \cdot m \beta_{m + 1} ~.
% 		\label{mincut}
% 	\end{aligned}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	By doing this, we relax the requirement of cut capacity constraints from $\boldsymbol{c}(n, m) \geq M$ to $\text{min}[\boldsymbol{c}'(n, m)] \geq M$ when $m$ nodes remain, and the size is decreased from $\binom{n}{m}$ to $1$.
% 	For the reconstruction of original data, $\text{min}[\boldsymbol{c}'(n, m)]$ for each stage should be greater than or equal to $M$, i.e.,
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\bigcup\limits_{m = k}^{n - 1} \text{min}[\boldsymbol{c}'(n, m)] \geq M ~.
% 	\label{eq.introduction.allmincut}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	In a word, storing all received data in the remaining nodes allows us to find the min-cut instead of using all cut capacity as capacity constraints.
% 	Moreover, this relaxation does not require additional transmissions, which means that the same linear combinations as those of the optimal strategy can be generated in subsequent repair stages.
% 	Therefore, the relaxation guarantees the reconstruction of data and leads to no increase in protection bandwidth compared to $\delta(n, k)_{min}$.

% 	With the simplified capacity constraints, we formulate a new \gls{LP} problem with lower complexity to minimize $\delta(n, k)$.
% 	Detailed analysis of the relaxation can be found in~\ref{paper.iot2019}.
% 	In addition, a complexity and performance analysis of the optimal solution and the low-complexity solution for the protection problem are given in~\ref{paper.iot2019}.
% 	These results allowed us to accomplish \ref{itm:obj4} of Chapter~\ref{ch.objectives}.

% 	\section{Optimal Generation Size of RLNC}
% 	\label{sec.optimal_g}

% 	For the protection problem, all the investigations above are from an information flow point of view, which provide a theoretical framework, and allow us to determine a lower bound on the cost.
% 	To apply the proposed solutions in real systems, we need to consider practical factors that might affect their performances.
% 	We focus on the effect of practical parameters of network coding in order to determine the optimal set of parameters that yields performance that is closest to the theoretical optimal.
% 	When using \gls{RLNC}, it is straightforward that a larger field size leads to a higher probability of decoding/reconstructing the original data, but higher computational complexity and more protection bandwidth.
% 	While the effect of the generation size is more complicated, we focus on how it affects the protection bandwidth, and how to determine the optimal one.

% 	Wit the proposed solutions, the protection problem $\mathbb{P}(n, k)$ is solved with the optimal strategy $(\beta_{k + 1}^{op}, \ldots, \beta_n^{op})$, achieving minimum bandwidth $\delta(n, k)_{min}$.
% 	The optimal strategy indicates that achieving $\delta(n, k)_{min}$ requires each remaining node to transmit precise $\beta_s^{op}$ bytes of network coded data in the repair stages, and less than $\beta_s^{op}$ bytes in any repair stage will lead to a failure of reconstruction.
% 	In practice, \gls{RLNC} is used introducing a number of restrictions and signaling requirements.
% 	To perform \gls{RLNC}, $M$ bytes of original data are divided into $G$ generations, with each generation having $g$ symbols each of equal size $S = M / (Gg)$ bytes.
% 	The encoded data is transmitted in the form of packets, where each packet includes an encoded symbol and the coding coefficients used to generate the coded symbol.
% 	There exist two sources of additional overhead using \gls{RLNC}: extra data and coding coefficients.

% 	The extra data overhead includes two parts.
% 	One is the zeros padding in symbols to ensure that they are of equal size when $S = M / (Gg)$ is not an integer.
% 	The other one is the overhead to produce integral symbols in repair stages.
% 	Nodes need to send $\lceil \beta_s^{op}/S \rceil$ symbols, which introduces unnecessary redundancy and more bandwidth when $\beta_s^{op} / S$ is not an integer.
% 	As for the coding coefficient overhead, the size of each coefficient depends on the field size, which is prescribed.
% 	The number of coding coefficients is the generation size $g$.
% 	Both sources of the additional overhead are affected by the choice of $g$, therefore, it is necessary to choose a proper generation size to reduce the additional overhead.
% 	Beyond overhead, a larger $g$ results in higher complexity because more symbols are combined to a coded symbol, and more arithmetic operations are required~\cite{heide2011code}.
% 	We choose $G = 1$ with the understanding that there can be added computational complexity, as mentioned above.
% 	The reason is that we would like to study minimal overhead, and $G = 1$ gives us more options to find the optimal generation size $g^*$ approaching $\delta(n, k)_{min}$ closest.

% 	Taking the additional overhead into account, we derive the estimated protection bandwidth $\delta(n, k)_{est}^{zp}$.
% 	The zero-padded symbol size is $S^{zp} = \left\lceil M / g \right\rceil$ and zero-padded file size is $M^{zp} = S^{zp} g = \left\lceil M / g \right\rceil g$.
% 	After zero-padding, the size of each transmission in a repair stage involving $s$ nodes is $\beta_s^{zp} = \beta_s^{op} M^{zp} / M$.
% 	Accordingly, the number of symbols/packets in the repair stage is
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\left\lceil \frac{\beta_s^{zp}}{S^{zp}} \right\rceil = \left\lceil \frac{\beta_s^{op} M^{zp} g}{M M^{zp}} \right\rceil = \left\lceil \frac{\beta_s^{op} g}{M} \right\rceil ~.
% 	% \label{}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	Adding $g$ coding coefficients from GF($2^q$) in each packet, the
% 	estimated protection bandwidth is
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\delta(n, k)_{est}^{zp} = \sum_{s = k + 1}^{n} s(s - 1) \left\lceil \frac{\beta_s^{op} g}{M} \right\rceil \left( \left\lceil \frac{M}{g} \right\rceil + \frac{gq}{8} \right) ~,
% 	\label{eq.introduction.est_zp}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	where $g$ is divisible by $n$ because each node has the same number of symbols, i.e., $n \mid g$. 
% 	For a protection problem $\mathbb{P}(n, k)$, we define the additional overhead ratio as
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	R = \frac{\delta(n, k)_{est}}{\delta(n, k)_{min}} ~,
% 	% \label{redun_ratio}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	where the minimum ratio $R_{min}$ is obtained when $g = g^*$.

% 	Eq.~\eqref{eq.introduction.est_zp} shows that there is a trade-off between the overhead of extra data and that of coding coefficients caused by the generation size $g$, which is not unexpected given the previous discussions on the overhead source.
% 	Therefore, we formulate an optimization problem to find the optimal generation size $g^*$ achieving minimum $\delta(n, k)_{est}^{zp}$ as
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\begin{aligned}
% 	\textbf{(P2)} \quad \text{min} \quad & \delta(n, k)_{est}^{zp} \\
% 	\text{s.t.} \quad & n \leq g \leq M \\
% 	& n \mid g ~,
% 	\end{aligned}
% 	% \label{op_g}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	where $g$ is the only variable, and the solution to the optimization will be $g^*$.
% 	The constraints guarantee that each node has the same number of symbols (at least one), and there is at least one byte in each symbol.
% 	Even though the theoretical range of $g$ is $n \leq g \leq M$, $n \mid g$, we do not choose $g$'s that are very large.
% 	This is because larger generation sizes will result in not only higher delay, but also larger coefficient overhead.
% 	Furthermore, the objective function is simple.
% 	Since $g^*$ is determined before a protection process, and will not be updated during the process, finding $g^*$ is not time-sensitive and can be carried out offline and stored in a table in the IoT devices.
% 	Based on the above, it is feasible to use brute-force to solve \textbf{(P2)} for our particular problem.
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[!ht]
% 		\centering
% 		\includegraphics[width=0.80\textwidth]{figures/introduction/Optimal_g_n10k5_zp.pdf}
% 		\caption{Protection bandwidth of $\mathbb{P}(10, 5)$ with different file sizes and different generation sizes (figure from~\ref{paper.iot2019}).}
% 		\label{fig.introduction.optimal_g_n10k5_zp}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	Fig.~\ref{fig.introduction.optimal_g_n10k5_zp} shows the protection bandwidth $\delta$ of $\mathbb{P}(10, 5)$ with different file sizes.
% 	It can be seen that for $\mathbb{P}(10, 5)$ with each file size, there exists an optimal generation size $g^*$ achieving minimum $\delta(10, 5)_{est}^{zp}$.
% 	Moreover, the larger the file size $M$ is, the lower the minimum ratio $R_{min}$ is.

% 	Besides the basic analysis above, more details can be found in~\ref{paper.iot2019}.
% 	A general way of solving \textbf{(P2)} as a \gls{MIQCQP} problem is presented.
% 	The effect of the generation size is discussed extensively, e.g., the value boundaries of $g$ achieving a given additional overhead tolerance $R \leq \eta$.
% 	These results allowed us to partially accomplish \ref{itm:obj5} of Chapter~\ref{ch.objectives}.

% 	\section{Implementation of Theoretical Results}
% 	\label{sec.implementation}

% 	To validate our theoretical results in practice, we build a software implementation of our protection strategy.
% 	Our system comprises of one data source/sink (DELL XPS 13 with Ubuntu 18.0.4) and ten network nodes (Raspberry Pi 3 Model B~\cite{RaspberryPi}, each with an Elecrow 5 Inch Touch Screen) as well as a WiFi access point.
% 	In the PC and Raspberry Pi's, \gls{RLNC} is performed using the Kodo library through the Python API~\cite{pedersen2011kodo, Kodo}.
% 	For simplicity, we use the PC as a source to distribute the original data to the Raspberry Pi's, which simulates the process of nodes collecting data in a real setting.
% 	This allows us to use the PC to validate the data after multiple losses and repair processes.
% 	Since our method focuses on repairing lost data when nodes fail regardless of where the data comes from, the simplification is reasonable and does not affect the results.

% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[!ht]
% 		\centering
% 		\includegraphics[width=0.80\textwidth]{figures/introduction/Repair stage.jpeg}
% 		\caption{Repair process started after the detection of loss of one node in the system with 10 Raspberry Pi nodes.}
% 		\label{fig.introduction.repairstage}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 	Fig.~\ref{fig.introduction.repairstage} depicts a repair process in the measurement.
% 	This repair process consists of recoding the data available at each of the nodes and generating a specific number of coded fragments to be transmitted to each node.
% 	The amount of data to be transmitted, i.e., the strategy $(\beta_{k + 1}^{op}, \ldots, \beta_n^{op})$, is precomputed by the low-complexity solution and stored in tables in the devices for different stages of the repair process.
% 	A test/measurement run continues to introduce losses for the system to repair until the number of available nodes reaches $k$.
% 	A comprehensive description of how a measurement runs is given in~\ref{paper.iot2019}.

% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[!ht]
% 		\centering
% 		\includegraphics[width=0.80\textwidth]{figures/introduction/Delta_10MB_g_n10k5.pdf}
% 		\caption{A comparison of measured, estimated and theoretical protection bandwidth with different generation sizes (figure from~\ref{paper.iot2019}).}
% 		\label{fig.introduction.measureddelta}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 	We measure the total network traffic while $\mathbb{P}(10, 5)$ with $M = 10$~MB is implemented.
% 	The data is encoded by \gls{RLNC} over GF($2^8$).
% 	For simplicity, we carry out measurements for $g$'s that are divisors of $M$, i.e., there is no need for zero padding.
% 	Fig.~\ref{fig.introduction.measureddelta} shows a comparison of measured, estimated and theoretical protection bandwidth with different generation sizes.
% 	When $g = 800$, the minimum additional overhead ratio of the measured $\delta$ is $R = 1.12$.
% 	Compared to $\delta_{min}$, the measured $\delta$ is 12~\% higher, which is a small deviation due to additional overhead and other protocol effects.
% 	The consistence between the measured and the estimated values proves the validity of our theoretical results.
% 	The components of the measured $\delta$ are examined in~\ref{paper.iot2019}.
% 	These results allowed us to accomplish \ref{itm:obj5} of Chapter~\ref{ch.objectives}.

% 	\section{Reducing Signaling in Optimal IoT Storage with A Leader}
% 	\label{sec.leader}

% 	For the protection problem $\mathbb{P}(n, k)$, both solutions proposed above require remaining nodes to contact each other to distribute redundancy equally in the system, which leads to $O(s^2)$ \gls{IoT} device-to-device connections for $s$ remaining nodes.
% 	The large number of connections will result in high consumptions of time and network resources.
% 	Fortunately, the issue can be addressed by introducing a lead node to coordinate the repair process without reducing the cost efficiency.

% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[!ht]
% 		\centering
% 		\includegraphics[width=1.0\textwidth]{figures/introduction/Protection with a leader.pdf}
% 		\caption{An example of the data protection problem with a leader.
% 		In the example, $n = 5$ and $k = 2$, the system carries out a repair every time a node fails.
% 		By three repairs, the original data can be reconstructed by the two surviving nodes (figure from~\cite{zhao2019leader}).}
% 		\label{fig.introduction.leaderprotection}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 	With the introduction of a leader, the network is not symmetric anymore.
% 	We therefore divide a node loss to two cases: an ordinary node fails or the leader fails.
% 	In the former, the leader recodes data right away and distributes this coded data to other nodes in the network to achieve a desired redundancy across the remaining nodes.
% 	Thus, the $\alpha$ fraction of the data stored in each node increases.
% 	In the latter, the system selects a new leader, which collects $M$ bits of data, encodes, and distributes coded data across the remaining nodes.
% 	This means that both cases share the phase where the leader encodes and distributes the data, while the latter needs to recreate a leader.
% 	A non-skipped repair stage may have one (distributing) or two (collecting and distributing) phases concerning data transmission, which depends on whether the leader survives the preceding failure or not.
% 	The analysis of the probability of the leader failure is omitted here. See~\ref{paper.cl2019} for details.
% 	% Therefore, we use a mean field approximation to compute the number of connections and the cost in a collecting phase.

% 	During the process, the storage in a leader is $\alpha^* = M$, and that of each ordinary node when $i$ nodes survive is denoted by $\alpha_i$ $(k \leq i \leq n)$.
% 	For simplicity, it is assumed that the leader and each ordinary node have the same probability to fail.
% 	Let $p_j$ $(k \leq j \leq n - 1)$ be the probability that all $j$ surviving nodes are ordinary nodes before a repair stage, and $p_{n} = 1$ since there is no leader in the network prior to the preparation stage.
% 	In a repair stage that $s$ $(k + 1 \leq s \leq n)$ nodes participate in, the expected number of connections $t_s$ is $(p_s + 1)(s - 1)$, of which $p_s(s - 1)$ connections occur in the collecting phase and $(s - 1)$ occur in the distributing phase.
% 	$t_s$ is of order $O(s)$.
% 	The repair bandwidth $\gamma_s$ is $(s - 1) (p_{s} \beta_s^c + \beta_s^d)$, where $\beta_s^c$ and $\beta_s^d$ are the sizes of coded data sent from each ordinary node to the leader in the collecting phase, and as well as coded data sent from the leader in the distributing phase.
% 	If the network skips the repair, both of $t_s$ and $\gamma_s$ will be zero.
% 	However, skipping a repair implies that the network needs to inject more redundancy in previous repair(s), which may raise the protection bandwidth.
% 	The number of total connections $T(n, k)$ is $\sum_{s = k + 1}^n t_s$, and the protection bandwidth $\delta(n, k)$ is the summation of all $\gamma_s$, i.e., $\delta(n, k) = \sum_{s = k + 1}^n (s - 1) (p_{s} \beta_s^c + \beta_s^d)$.
% 	Fig.~\ref{fig.introduction.leaderprotection} gives an example with $n = 5$, $k = 2$.

% 	In a repair stage involving $s$ nodes, the pair $(\beta_s^c, \beta_s^d)$ describe how much redundancy should be injected into the system.
% 	The pairs for all repair stages constitute a protection strategy from the perspective of the transmitted data.
% 	Since $(\beta_s^c, \beta_s^d)$ is obtained by storage fractions $\alpha$'s, we calculate the storage $\alpha_s$ for different repair stages, and use $(\alpha_n, \alpha_{n - 1}, \ldots, \alpha_k)$ as a strategy.
% 	In a strategy $(\alpha_n, \alpha_{n - 1}, \ldots, \alpha_k)$, $\alpha_n = M / n$, and $\alpha_j \geq M / j$, which is the minimum amount to guarantee the reconstruction of original data.
% 	Because $\alpha_k > M / k$ is not beneficial for reducing the protection bandwidth, we set $\alpha_k = M / k$.
% 	Moreover, nodes do not discard data that they have stored, i.e., $\alpha_{j + 1} \leq \alpha_j$.
% 	Accordingly, we have $\text{max}[M / j, \alpha_{j + 1}] \leq \alpha_{j} \leq M / k$.Based on the analysis above, a protection can be regarded as a process that the storage grows from $M / n$ to $M / k$, and a strategy indicates the growth path.
% 	Since any  $\alpha_j$ within $[\text{max}(M / j, \alpha_{j + 1}), M / k]$ is satisfactory, we classify the infinite strategies by patterns, which is a series of decisions for repairs.
% 	We take $e_s$ to indicate the decision of the repair stage involving $s$ nodes as
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\begin{aligned}
% 	e_s =
% 	\begin{cases}
% 	1 ~~~~ \text{if perform the repair} & \alpha_{s - 1} > \alpha_{s} \\
% 	0 ~~~~ \text{if skip the repair} & \alpha_{s - 1} = \alpha_{s} ~.
% 	\end{cases}
% 	\end{aligned}
% 	% \label{}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	For a pattern $[e_n, e_{n - 1}, \ldots, e_{k + 1}]$, the strategy achieving locally minimum bandwidth in this pattern set is called a locally optimal strategy.
% 	Then the (globally) optimal strategy can be selected within the pool of locally optimal strategies.
% 	It can be proved that for any pattern $[e_n, e_{n - 1}, \ldots, e_{k + 1}]$, the storage fractions in the locally optimal strategy are in the set $[M/(n - 1), M/(n - 2), \ldots, M/k]$.
% 	The complete proof is given in~\ref{paper.cl2019}.
% 	Consequently, the locally optimal strategies can be mapped to paths in a graph with a starting point $\left(n, M / n \right)$ and an ending point $\left(k, M / k \right)$, as shown in Fig.~\ref{fig.introduction.pathgraph}.

% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{figure}[!ht]
% 		\centering
% 		\includegraphics[width=0.85\textwidth]{figures/introduction/Path graph.pdf}
% 		\caption{A path graph of locally optimal strategies for a protection problem. Each path corresponds to a locally optimal strategy, and shows how the storage grows from $M / n$ to $M / k$ (figure from~\cite{zhao2019leader}).}
% 		\label{fig.introduction.pathgraph}
% 	\end{figure}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 	Based on the path graph, a \gls{VLIS} is proposed to calculate the optimal strategy with low complexity by exploiting the underlying structure of the problem.
% 	Numerical results show that the proposed optimal strategy for a system with a leader requires no more bandwidth use than one without a leader, but it reduces the number of connections from $O(s^2)$ to $O(s)$ for $s$ surviving nodes.
% 	Detailed illustrations of \gls{VLIS} and evaluations of the proposed optimal strategy can be found in~\ref{paper.cl2019}.
% 	These results allowed us to partially accomplish \ref{itm:obj6} of Chapter~\ref{ch.objectives}.

% 	% \newpage

% 	\section{Minimum Bandwidth Use in Reliable IoT with Random Device Failures}
% 	\label{sec.random_failures}

% 	In previous sections, the protection problem is studied with an assumption that node losses occur one at a time and that the system can react sufficiently fast before the next loss occurs.
% 	Although the proposed strategies may skip certain stage(s) and repair multiple failures in one stage for saving cost, adopting them directly to the problem with random failures could be problematic.
% 	This is because when using approaches designed for the case of one loss at a time, the limits of protection capability are very likely to be broken, which will cause permanent loss of data.
% 	Therefore, it is necessary to investigate the protection problem with random failures per event, and identify the optimal strategy for this case.

% 	Following the framework in Section~\ref{sec.leader}, we generalize and formulate the protection problem with a leader coordinating the repair process for random failure events.
% 	Although the repair stage is analogously divided into two phases, collecting phase and distributing phase, the protection process is formulated in a more general and complex way.
% 	We consider that an $n$-node network has $M$ bits of initial data, where each node has generated $M / n$ bits.
% 	In a protection process, we denote a series of failure events as $F_t = (f_1, \ldots, f_t)$, where $f_i$ $(1 \leq i \leq t)$ is the number of failures in the $i$th event.
% 	Let the number of remaining nodes after the $j$th failure event be $r_{j} = n - \sum_{l = 0}^{j} f_l$ $(0 \leq j \leq t)$.
% 	Since there is at least one failure in each event and the number of surviving nodes at the end is $k = n - \sum_{i=1}^t f_i$, we have $1 \leq t \leq \sum_{i=1}^t f_i \leq n-1$.

% 	The strategies are classified by patterns $[e_1, \ldots, e_t]$, where $e_i$ to indicate the decision of the $i$th repair stage.
% 	Due to the fact that failures do not occur one by one, we need to handle the probability of the leader failure more carefully, which is important for calculating expected bandwidth and connection number.  
% 	Let the probability that the leader fails in the $i$th failure be $p_i$.
% 	We formulate $p_i$ as
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	\begin{equation}
% 	\begin{aligned}
% 	p_i =
% 	\begin{cases}
% 	\frac{f_i}{n - \sum_{l = 0}^{i - 1} f_l} & \text{if}~e_{i} = 1, \\
% 	\frac{\sum_{a = i - w - 1}^{i} f_a}{n - \sum_{b = 0}^{i - w - 2} f_b} & \text{if}~\sum_{g = 0}^{w} e_{i - g} = 0 \wedge e_{i - w - 1} = 1 ~.
% 	\end{cases}
% 	\end{aligned}
% 	% \label{}
% 	\end{equation}
% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	The derivation of $p_i$ is given in~\ref{paper.ew2019}.
% 	With $p_i$, the bandwidth of a particular strategy can be obtained.
% 	Similar to the work in~\ref{paper.cl2019}, the optimal strategy with minimum bandwidth can be determined based on a path graph.
% 	A \gls{VLOSS} is devised to search the optimal strategy for the protection problem with the random number of failures.
% 	More details and the results that show the proposed optimal strategy's performance can be found in~\ref{paper.ew2019}.
% 	These results allowed us to accomplish \ref{itm:obj6} of Chapter~\ref{ch.objectives}.


	\bibliographystyle{IEEEtran}
	\tocless\bibliography{back/bibliography}